import json
import os

import idaapi
import idc
import ida_nalt
import ida_bytes

name_replacements = {"EventHandler": "EventHandler_"}
mapped_types = {
    "void": "__int64",
    "bool": "bool",
    "char": "char",
    "byte": "byte",
    "sbyte": "signed __int8",
    "short": "__int16",
    "ushort": "unsigned __int16",
    "int": "__int32",
    "uint": "unsigned __int32",
    "long": "__int64",
    "ulong": "unsigned __int64",
    "float": "float",
    "double": "double",
    "nint": "__int64",
}

data = None
path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../metadata.json")

print("+ loading metadata.json from", path)
with open(path, "r") as f:
    data = json.load(f)
print("+ loaded metadata.json")

enums = data["Enums"]
structs = data["Structs"]
unions = data["Unions"]
functions = data["Functions"]
globals = data["Globals"]

known_types = []
decl_str = "// Generated by metadata_importer.py - do not edit!"
values_to_write = []


def get_type_from_name(name):
    """
    Gets a tinfo_t from a given name.
    """

    tinfo = idaapi.tinfo_t()
    if name in mapped_types:
        idaapi.parse_decl(
            tinfo, idaapi.get_idati(), mapped_types[name] + ";", idaapi.PT_SIL
        )
    else:
        tinfo.get_named_type(idaapi.get_idati(), name)
    return tinfo


def lookup_size(name):
    """
    Lookup the size of a struct or enum.
    Attempts to use the "Size" field in metadata, falling back to IDA's type system.
    """

    for struct in data["Structs"]:
        struct_name = struct["Name"]
        struct_size = struct["Size"]
        if struct_name == name and struct_size is not None:
            return struct_size

    for enum in data["Enums"]:
        if enum["Name"] == name:
            type_key = "Type" if "Type" in enum else "UnionType"
            return get_type_from_name(enum[type_key]).get_size()

    return get_type_from_name(name).get_size()


def get_value(name):
    for value in values_to_write:
        if value["data"]["Name"] == name:
            return value

    return None


def get_name(str):
    """
    Fix names that are reserved by IDA.
    """

    name = str
    for replacement in name_replacements:
        if replacement in name:
            name = name.replace(replacement, name_replacements[replacement])
    return name


def ensure_field_dependency(field):
    """
    Ensure a field's dependency in a struct or union is written.
    This causes issues when a struct references another struct that is defined later, even with forward references.
    """

    type_key = "Type" if "Type" in field else "UnionType"
    raw_type = field[type_key]
    maybe_value = get_value(raw_type)
    if (
        maybe_value is not None
        and maybe_value["data"]["Name"] not in known_types
        and maybe_value["type"] in ["struct", "union"]
    ):
        # This is a similar issue in CExporter, I'll quote awgil on this one:
        # make sure we export pointed-to type, but don't do it immediately - otherwise we might end up adding definition for a structure X containing member of type Y before Y, if Y has X* member
        if field["PointerIndirection"] == 0:
            write_value(maybe_value)


def write_c_enum(enum):
    """
    Write an enum to the declaration string.
    """
    global decl_str

    type_key = "Type" if "Type" in enum else "UnionType"
    enum_str = "enum {0} : {1} {{\n".format(get_name(enum["Name"]), enum[type_key])

    for name, value in enum["Values"].items():
        enum_str += " {0} = {1},\n".format(name, value)

    enum_str += "};"
    decl_str += "\n" + enum_str


def write_c_struct(struct):
    """
    Write a struct to the declaration string.
    """
    global decl_str

    struct_str = "struct {0} {{\n".format(get_name(struct["Name"]))
    last_offset = 0

    def ensure_padding(last_offset, field_offset):
        nonlocal struct_str
        pad_size = field_offset - last_offset
        if pad_size > 0:
            struct_str += "  byte _pad{0}[{1}];\n".format(
                hex(last_offset), hex(pad_size)
            )

    for field in struct["Fields"]:
        ensure_padding(last_offset, field["Offset"])
        ensure_field_dependency(field)

        type_key = "Type" if "Type" in field else "UnionType"
        type = get_name(field[type_key])
        if type in mapped_types:
            type = mapped_types[type]

        if field["PointerIndirection"] > 0:
            type += "*"

        struct_str += "  {0} {1}".format(type, field["Name"])
        if field["ArraySize"] > 1:
            struct_str += "[{0}]".format(hex(field["ArraySize"]))
        struct_str += ";\n"

        last_offset = (
            field["Offset"]
            + lookup_size(get_name(field[type_key])) * field["ArraySize"]
        )

        # If this is the last field, pad to the end as well
        struct_size = struct["Size"]
        if field == struct["Fields"][-1] and struct_size is not None:
            ensure_padding(last_offset, struct_size)

    struct_str += "};"
    decl_str += "\n" + struct_str


def write_c_union(union):
    """
    Write a union to the declaration string.
    """
    global decl_str

    union_str = "union {0} {{\n".format(get_name(union["Name"]))

    for field in union["Fields"]:
        ensure_field_dependency(field)
        type_key = "Type" if "Type" in field else "UnionType"
        type = get_name(field[type_key])
        if type in mapped_types:
            type = mapped_types[type]

        if field["PointerIndirection"] > 0:
            type += "*"

        union_str += "  {0} {1}".format(type, field["Name"])
        if field["ArraySize"] > 1:
            union_str += "[{0}]".format(hex(field["ArraySize"]))
        union_str += ";\n"

    union_str += "};"
    decl_str += "\n" + union_str


def write_forward_decl(value):
    """
    Write a forward declaration to the declaration string.
    """
    global decl_str

    type = value["type"]
    data = value["data"]
    name = data["Name"]

    if type == "union":
        decl_str += "\nunion {0};".format(get_name(name))
    if type == "struct":
        decl_str += "\nstruct {0};".format(get_name(name))
    if type == "enum":
        decl_str += "\nenum {0};".format(get_name(name))


def write_value(value):
    """
    Write a value to the declaration string.
    """

    type = value["type"]
    data = value["data"]
    name = data["Name"]

    if name in known_types:
        # We already wrote the struct, don't cause a stack overflow
        return
    else:
        known_types.append(name)

    if type == "union":
        write_c_union(data)
    if type == "struct":
        write_c_struct(data)
    if type == "enum":
        write_c_enum(data)


def sigscan(sig, do_jmp_call):
    """
    Scan for a function signature.
    """

    # Stolen from sigmaker
    fmt_sig = [
        int(s, 16).to_bytes(1, "little") if s != "??" else b"\0" for s in sig.split(" ")
    ]
    fmt_sig = b"".join(fmt_sig)

    sig_mask = [int(b != "??").to_bytes(1, "little") for b in sig.split(" ")]
    sig_mask = b"".join(sig_mask)

    addr = ida_bytes.bin_search(
        idc.get_inf_attr(idc.INF_MIN_EA),
        idc.get_inf_attr(idc.INF_MAX_EA),
        fmt_sig,
        sig_mask,
        ida_bytes.BIN_SEARCH_FORWARD,
        ida_bytes.BIN_SEARCH_NOCASE,
    )

    if addr == idc.BADADDR:
        return None

    if do_jmp_call:
        first_byte = ida_bytes.get_byte(addr)
        if first_byte == 0xE8 or first_byte == 0xE9:
            offset = ida_bytes.get_dword(addr + 1)
            # uint to int
            if offset > 0x7FFFFFFF:
                offset -= 0x100000000
            addr = addr + 5 + offset

    return addr


def resolve_address(addr_info):
    """
    Resolve an AddressInfo from metadata.json to an address.
    """

    type = addr_info["Type"]

    if type == "MemberFunction":
        return sigscan(addr_info["Signature"], True)
    elif type == "VirtualFunction":
        # todo
        return None

    return None


def get_tinfo_from_type(raw_type):
    """
    Retrieve a tinfo_t from a raw type string.
    """

    type_tinfo = idaapi.tinfo_t()
    ptr_tinfo = None

    ptr_count = raw_type.count("*")
    type = raw_type.rstrip("*")

    if type in mapped_types:
        type = mapped_types[type]

    if not type_tinfo.get_named_type(idaapi.get_idati(), type):
        terminated = type + ";"
        if (
            idaapi.parse_decl(type_tinfo, idaapi.get_idati(), terminated, idaapi.PT_SIL)
            is None
        ):
            print("! failed to parse type '{0}'".format(type))
            return None

    if ptr_count > 0:
        ptr_tinfo = idaapi.tinfo_t()
        for i in range(ptr_count):
            if not ptr_tinfo.create_ptr(type_tinfo):
                print("! failed to create pointer")
                return None
    else:
        ptr_tinfo = type_tinfo

    return ptr_tinfo


def set_arg(addr, idx, type, name, func_name):
    """
    Set a function argument's name and type.
    """

    tinfo = idaapi.tinfo_t()
    if not ida_nalt.get_tinfo(tinfo, addr):
        print("! failed to get tinfo for {0} - {1}".format(func_name, name))
        pass

    funcdata = idaapi.func_type_data_t()
    if not tinfo.get_func_details(funcdata):
        print("! failed to get func details for {0} - {1}".format(func_name, name))
        pass

    if funcdata.size() <= idx:
        print(
            "! less arguments than expected for {0} - {1} (tried to set {2}, but func has {3})".format(
                name, func_name, idx, funcdata.size()
            )
        )
        return

    funcdata[idx].name = name

    type_tinfo = get_tinfo_from_type(type)
    if type_tinfo is None:
        print("! failed to get tinfo for {0} - {1}".format(func_name, name))
        return

    orig_type = funcdata[idx].type
    if orig_type is None:
        print("! failed to get original type for {0} - {1}".format(func_name, name))
        return

    if orig_type.get_size() < type_tinfo.get_size():
        print(
            "! type size mismatch for {0} - {1} (expected {2}, got {3})".format(
                name, func_name, type_tinfo.get_size(), orig_type.get_size()
            )
        )
        return

    funcdata[idx].type = type_tinfo

    new_tinfo = idaapi.tinfo_t()
    if not new_tinfo.create_func(funcdata):
        print("! failed to create function type for {0} - {1}".format(func_name, name))
        return

    idaapi.apply_tinfo(addr, new_tinfo, idaapi.TINFO_DEFINITE)


def import_function(function):
    """
    Import a function's name, arguments, and return type.
    """

    name = function["Name"]
    addr = resolve_address(function["AddressInfo"])

    if addr is None:
        print("! failed to resolve address for", name)
        return

    # set name of func
    idc.set_name(addr, name, idc.SN_NOWARN)

    # set args
    for idx, arg in enumerate(function["Arguments"]):
        raw_type = arg[0]
        name = arg[1]
        set_arg(addr, idx, raw_type, name, function["Name"])

    # set return type
    ret_tinfo = get_tinfo_from_type(function["ReturnType"])
    if ret_tinfo is None:
        print("! failed to get tinfo for", name)
        return

    func_tinfo = idaapi.tinfo_t()
    funcdata = idaapi.func_type_data_t()
    if not ida_nalt.get_tinfo(func_tinfo, addr):
        print("! failed to get tinfo for", name)
        return

    if not func_tinfo.get_func_details(funcdata):
        print("! failed to get func details for", name)
        return

    if funcdata.rettype.get_size() < ret_tinfo.get_size():
        print(
            "! return type size mismatch for {0} (expected {1}, got {2})".format(
                name, ret_tinfo.get_size(), funcdata.rettype.get_size()
            )
        )
        return

    funcdata.rettype = ret_tinfo
    if not func_tinfo.create_func(funcdata):
        print("! failed to create function type for", name)
        return

    idaapi.apply_tinfo(addr, func_tinfo, idaapi.TINFO_DEFINITE)


def import_global(glb):
    addr = sigscan(glb["Signature"], False)
    offset = glb["Offset"]
    if addr is None:
        print("! failed to resolve address for", glb["Name"])
        return

    access_offset = ida_bytes.get_dword(addr + offset)
    addr = addr + offset + 4 + access_offset

    idc.set_name(addr, glb["Name"], idc.SN_NOWARN)

    # set type
    tinfo = get_tinfo_from_type(glb["Type"])
    if tinfo is None:
        print("! failed to get tinfo for", glb["Name"])
        return

    idaapi.apply_tinfo(addr, tinfo, idaapi.TINFO_DEFINITE)


def build_and_import_decls():
    global enums, structs, unions, decl_str, values_to_write

    print("+ building C declaration")
    values_to_write = [
        [{"type": "enum", "data": enum} for enum in enums],
        [{"type": "struct", "data": struct} for struct in structs],
        [{"type": "union", "data": union} for union in unions],
    ]
    # Flatten the list
    values_to_write = [item for sublist in values_to_write for item in sublist]

    decl_str += "\n// Forward declarations\n"
    for value in values_to_write:
        write_forward_decl(value)

    decl_str += "\n\n// Definitions\n"
    for value in values_to_write:
        write_value(value)

    print("+ built declaration, {0} lines".format(len(decl_str.split("\n"))))

    result = idc.parse_decls(decl_str, idaapi.PT_SIL)
    if result == 0:
        print("+ imported declaration")
    else:
        print("! failed to import declaration")


build_and_import_decls()

print("+ importing functions")
for function in functions:
    import_function(function)

print("+ importing globals")
for glb in globals:
    import_global(glb)

print("+ done :3")
